{"version":3,"sources":["operations.js","dictionary.js","App.js","reportWebVitals.js","index.js"],"names":["op","addition","x","y","parseFloat","subtraction","multiplication","division","percentage","exponent","fraction","sqrt","Math","abs","neg","byHundred","buttons","name","func","trigger","buttonMap","App","useState","val1","cPrint","v1","v2","f","store","cStore","loop","cLoop","mem","cMem","className","Card","style","width","height","background","padding","margin","marginTop","Header","textAlign","marginRight","marginLeft","Body","map","v","i","val","Button","onClick","e","value","target","toggle","toggleVar","writeFunc","includes","isNaN","pr","length","slice","onclick","display","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.b1856b04.chunk.js","sourcesContent":["const addition = (x, y) => parseFloat(x) + parseFloat(y);\r\nconst subtraction = (x, y) => parseFloat(x) - parseFloat(y);\r\nconst multiplication = (x, y) => parseFloat(x) * parseFloat(y);\r\nconst division = (x, y) => parseFloat(x) / parseFloat(y);\r\nconst percentage = (x, y) => (parseFloat(x) / 100) * parseFloat(y);\r\nconst exponent = (x) => parseFloat(x) ** 2;\r\nconst fraction = (x) => parseFloat(x) / 100 / 100;\r\nconst sqrt = (x) =>\r\n  Math.sqrt(parseFloat(x < 0 ? Math.abs(x) : x)) * (x < 1 ? -1 : 1);\r\nconst neg = (x) => x * -1;\r\nconst byHundred = (x) => {\r\n  return parseFloat(x) / 100;\r\n};\r\n\r\nconst op = {\r\n  addition,\r\n  subtraction,\r\n  multiplication,\r\n  division,\r\n  percentage,\r\n  exponent,\r\n  fraction,\r\n  sqrt,\r\n  neg,\r\n  byHundred,\r\n};\r\nexport default op;\r\n","import op from \"./operations\";\r\n\r\nexport const buttons = [\r\n  [\r\n    { name: \"MC\" },\r\n    { name: \"MR\" },\r\n    { name: \"M+\" },\r\n    { name: \"M-\" },\r\n    { name: \"MS\" },\r\n  ],\r\n  [\r\n    { name: \"%\", func: op.byHundred, trigger: true },\r\n    { name: \"CE\" },\r\n    { name: \"C\" },\r\n    { name: \"DEL\" },\r\n  ],\r\n  [\r\n    { name: \"1/x\", func: op.fraction, trigger: true },\r\n    { name: \"x^2\", func: op.exponent, trigger: true },\r\n    { name: \"sqrt(x)\", func: op.sqrt, trigger: true },\r\n    { name: \"รท\", func: op.division },\r\n  ],\r\n  [\r\n    { name: 7 },\r\n    { name: 8 },\r\n    { name: 9 },\r\n    { name: \"x\", func: op.multiplication },\r\n  ],\r\n  [{ name: 4 }, { name: 5 }, { name: 6 }, { name: \"-\", func: op.subtraction }],\r\n  [{ name: 1 }, { name: 2 }, { name: 3 }, { name: \"+\", func: op.addition }],\r\n  [\r\n    { name: \"+/-\", func: op.neg, trigger: true },\r\n    { name: 0 },\r\n    { name: \".\" },\r\n    { name: \"=\" },\r\n  ],\r\n];\r\n","import React, { useState } from \"react\";\nimport \"./App.css\";\nimport Button from \"react-bootstrap/Button\";\nimport Card from \"react-bootstrap/Card\";\nimport { buttons } from \"./dictionary\";\nimport \"bootstrap/dist/css/bootstrap.min.css\";\n\nconst buttonMap = buttons || [];\n\nfunction App() {\n  //Student info under the cut\n  //#region student note\n  //Student note:\n  //this project uses React Hooks for state management, using functional components\n  //as opposed to class components, for more info :\n  // https://reactjs.org/docs/hooks-intro.html\n\n  //To not worry about that, remember a simple naming scheme for state management below:\n\n  //const[value1, changerFunction1] = useState(\"inital value\")\n\n  //functionally the same as\n  // this.State({ value1 : \"inital value\"})\n  //instead of this.setState({ value1:\" new state\"}) format\n  //we use changerFunction(\"new state\")\n\n  //observe naming convention for value/changer pair in my state implementation as\n  //[stateVal, cStateVal]\n  //as you read through just remember that any function format cStateVal(\"newVal\")\n  //updates state variable with corresponding name to \"newVal\"\n  //#endregion\n  //#region State\n  //print to console\n  const [val1, cPrint] = useState(\"\");\n  //store container obj to contain functor x2 and a function\n  const [store, cStore] = useState({ v1: \"\", v2: \"\", f: \" \" });\n  //on certain cases we may need second functionality on a button, this will allow for\n  //this logic\n  const [loop, cLoop] = useState(false);\n  //memory store\n  const [mem, cMem] = useState(0);\n  //#endregion\n\n  //#region Button Clcik\n  const onclick = (e, func, trigger) => {\n    const value = e.target.value;\n    //this is the primary logic of the calc function\n    //state stores val1, val2, and functor\n    //if there is no functor logic writes on val1\n    //else logic writes on val2\n\n    //return context specific state changing function\n    let toggle = typeof store.f === \"function\";\n    //return conetxt specific state value\n    let toggleVar = toggle ? store.v2 : store.v1;\n    //return conetxt specific state changing function\n    let writeFunc = (x, y) => {\n      //optionally add ability to change store function with ternary\n      toggle\n        ? cStore({ ...store, v2: x, f: y ? y : store.f })\n        : cStore({ ...store, v1: x, f: y ? y : store.f });\n      return toggle ? store.v2 : store.v1;\n    };\n\n    if (value === \".\") {\n      if (toggleVar.includes(\".\")) return;\n      writeFunc(!toggleVar ? \"0.\" : toggleVar + \".\");\n      cPrint(!toggleVar ? \"0.\" : toggleVar + \".\");\n      return;\n    }\n\n    //master switch filter\n    switch (!isNaN(value)) {\n      //if number is clicked\n      case true:\n        //referenceing context specific state var\n        //handle trailing zeros/if we want to reset start of equation]\n        //if were looping on the \"=\", reset equation, hard code override write on v1, stop loop\n        if (loop) {\n          cStore({ ...store, v1: value, v2: 0, f: \" \" });\n          cPrint(value);\n          //stop loop\n          cLoop(false);\n          //if state == 0 or state needs to be cleared\n        } else if (toggleVar === 0 || store.f === \"clear\") {\n          //context specific change state function changes value\n          //also clears function if its set on clear, or if empty, we set the function passed in\n          writeFunc(value, store.f === \"clear\" ? \" \" : func);\n          cPrint(value);\n        } else {\n          //else concat on end of state\n          writeFunc(toggleVar + value);\n          cPrint(toggleVar + value);\n        }\n        break;\n\n      //if operator is clicked\n      case false:\n        //else if button is not a number\n        switch (value) {\n          //DEL\n          case \"DEL\":\n            //overwrite context specific state value\n            if (loop) {\n              cStore({\n                ...store,\n                v1: 0,\n              });\n              return;\n            }\n\n            let pr = writeFunc(\n              //if there is NOT a function\n              !toggle || loop\n                ? //either remove last or set to zero on v1\n                  store.v1.length > 1\n                  ? store.v1.slice(0, -1)\n                  : 0\n                : //or else repeat to v2\n                store.v2.length > 1\n                ? store.v2.slice(0, -1)\n                : 0\n            );\n            cPrint(pr > 0 ? pr.slice(0, -1) : 0);\n\n            break;\n\n          //memory functions\n          case \"MC\":\n            cMem(0);\n            break;\n          case \"MS\":\n            cPrint(\" \");\n            cMem(store.v1);\n            cStore({ ...store, v1: \"\", f: \" \" });\n            break;\n          case \"M-\":\n            cPrint(mem - store.v1);\n            cStore({ ...store, v1: mem - store.v1 });\n            cLoop(true);\n            break;\n          case \"M+\":\n            cPrint(mem + store.v1);\n            cStore({ ...store, v1: mem + store.v1 });\n            cLoop(true);\n            break;\n          case \"MR\":\n            cPrint(mem);\n            cStore({ ...store, v1: mem, v2: 0 });\n            break;\n\n          //clear\n          case \"C\":\n            cPrint(0);\n            cStore({ v1: \"\", v2: \"\", f: \" \" });\n            cMem(0);\n            break;\n          case \"CE\":\n            cPrint(\"\");\n            if (loop) {\n              cStore({ ...store, v1: 0, v2: 0 });\n            } else {\n              writeFunc(\"\");\n            }\n            // cLoop(false);\n            break;\n          //equals\n          case \"=\":\n            //error catch if no function should be the last chance for this to break\n            if (typeof store.f !== \"function\") return;\n            else {\n              //set print as the return of functor from state with val1 and val2 input\n              cPrint(() => store.f(store.v1, store.v2));\n              //prepare store to begin looping by incrementing\n              cStore({ ...store, v1: store.f(store.v1, store.v2) });\n              //set loop ability\n              cLoop(true);\n            }\n            break;\n\n          //if button has not been specified that means we pass onto the following logic\n          default:\n            //if function and trigger are present, run function, reset state, prepare\n            //\"clear\" functionality\n            //trigger is defined to know that we only need 1 input for our math, not 2\n            if (func && trigger) {\n              if (!store.v1) return;\n              //run func and store in state\n              //reset v2\n              //set functor to clear\n              cStore({ v1: func(store.v1), v2: 0, f: \"clear\" });\n              cPrint(func(store.v1));\n              cLoop(false);\n            } else if (store.f && !trigger) {\n              //if no trigger is passed in, we know were waiting for the second user input\n              cStore({\n                ...store,\n                //note, if we have v1, v2, and func, assume user is chaining inputs. Calculate v1, change\n                //function, reset v2\n                v1:\n                  store.v1 && store.v2 && func && !loop\n                    ? store.f(store.v1, store.v2)\n                    : store.v1,\n                v2: store.v1 && store.v2 && func ? 0 : store.v2,\n                //store new function in store\n                f: func,\n              });\n              cLoop(false);\n              if (store.v1 && store.v2 && func && !loop)\n                cPrint(store.f(store.v1, store.v2));\n            }\n\n            break;\n        }\n        break;\n      default:\n        break;\n    }\n  };\n  //#endregion\n\n  //#region jsx\n\n  return (\n    <div className=\"App\">\n      <Card\n        style={{\n          width: \"500px\",\n          height: \"390px\",\n          background: \"grey\",\n          padding: \"10px\",\n          margin: \"auto\",\n          marginTop: \"20px\",\n        }}\n      >\n        <Card.Header\n          style={{\n            textAlign: \"right\",\n            marginRight: \"20px\",\n            marginTop: \"10px\",\n            marginLeft: \"20px\",\n            background: \"lightGrey\",\n          }}\n        >\n          {/* <br />\n          {mem}m\n          <br />\n          {val1}p\n          <br />\n          {store.v1}v1\n          <br />\n          {store.v2}v2\n          <br /> */}\n          {val1 || 0}\n        </Card.Header>\n        <Card.Body>\n          {buttonMap.map((v, i) => {\n            return (\n              <div className=\"btn-toolbar\" key={i}>\n                {v.map((val, i) => {\n                  return (\n                    <Button\n                      onClick={(e) => {\n                        onclick(e, val.func, val.trigger);\n                      }}\n                      key={val.name}\n                      value={val.name}\n                      style={{\n                        display: \"inline-block\",\n                        width: val.name[0] === \"M\" ? \"87px\" : \"109px\",\n                      }}\n                    >\n                      {val.name}\n                    </Button>\n                  );\n                })}\n              </div>\n            );\n          })}\n        </Card.Body>\n      </Card>\n    </div>\n  );\n  //#endregion\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}